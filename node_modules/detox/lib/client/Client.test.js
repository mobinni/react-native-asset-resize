'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var config = require('../configurations.mock').validOneDeviceAndSession.session;
var invoke = require('../invoke');

describe('Client', function () {var connect = function () {var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(















































































































    function _callee12() {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:
              client = new Client(config);
              client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"ready","params": {}}'));_context12.next = 4;return (
                client.connect());case 4:
              client.ws.isOpen.mockReturnValue(true);case 5:case 'end':return _context12.stop();}}}, _callee12, this);}));return function connect() {return _ref12.apply(this, arguments);};}();var WebSocket = void 0;var Client = void 0;var client = void 0;beforeEach(function () {jest.mock('npmlog');WebSocket = jest.mock('./AsyncWebSocket');Client = require('./Client');});it('reloadReactNative() - should receive ready from device and resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"ready","params": {}}'));_context.next = 5;return client.reloadReactNative();case 5:case 'end':return _context.stop();}}}, _callee, undefined);})));it('reloadReactNative() - should throw if receives wrong response from device', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"somethingElse","params": {}}'));_context2.prev = 3;_context2.next = 6;return client.reloadReactNative();case 6:_context2.next = 11;break;case 8:_context2.prev = 8;_context2.t0 = _context2['catch'](3);expect(_context2.t0).toBeDefined();case 11:case 'end':return _context2.stop();}}}, _callee2, undefined, [[3, 8]]);})));it('sendUserNotification() - should receive ready from device and resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"userNotificationDone","params": {}}'));_context3.next = 5;return client.sendUserNotification();case 5:expect(client.ws.send).toHaveBeenCalledTimes(2);case 6:case 'end':return _context3.stop();}}}, _callee3, undefined);})));it('waitUntilReady() - should receive ready from device and resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"ready","params": {}}'));_context4.next = 5;return client.waitUntilReady();case 5:expect(client.ws.send).toHaveBeenCalledTimes(2);case 6:case 'end':return _context4.stop();}}}, _callee4, undefined);})));it('cleanup() - if connected should send cleanup action and close websocket', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_context5.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"cleanupDone","params": {}}'));_context5.next = 5;return client.cleanup();case 5:expect(client.ws.send).toHaveBeenCalledTimes(2);case 6:case 'end':return _context5.stop();}}}, _callee5, undefined);})));it('cleanup() - if not connected should do nothing', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:client = new Client(config);client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"cleanupDone","params": {}}'));_context6.next = 4;return client.cleanup();case 4:expect(client.ws.send).not.toHaveBeenCalled();case 5:case 'end':return _context6.stop();}}}, _callee6, undefined);})));it('execute() - "invokeResult" on an invocation object should resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {var call;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:_context7.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"invokeResult","params":{"id":"0","result":"(GREYElementInteraction)"}}'));call = invoke.call(invoke.IOS.Class('GREYMatchers'), 'matcherForAccessibilityLabel:', 'test');_context7.next = 6;return client.execute(call());case 6:expect(client.ws.send).toHaveBeenCalledTimes(2);case 7:case 'end':return _context7.stop();}}}, _callee7, undefined);})));it('execute() - "invokeResult" on an invocation function should resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {var call;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:_context8.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"invokeResult","params":{"id":"0","result":"(GREYElementInteraction)"}}'));call = invoke.call(invoke.IOS.Class('GREYMatchers'), 'matcherForAccessibilityLabel:', 'test');_context8.next = 6;return client.execute(call);case 6:expect(client.ws.send).toHaveBeenCalledTimes(2);case 7:case 'end':return _context8.stop();}}}, _callee8, undefined);})));it('execute() - "testFailed" result should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {var call;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:_context9.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"testFailed","params": {"details": "this is an error"}}'));call = invoke.call(invoke.IOS.Class('GREYMatchers'), 'matcherForAccessibilityLabel:', 'test');_context9.prev = 4;_context9.next = 7;return client.execute(call);case 7:_context9.next = 12;break;case 9:_context9.prev = 9;_context9.t0 = _context9['catch'](4);expect(_context9.t0).toBeDefined();case 12:case 'end':return _context9.stop();}}}, _callee9, undefined, [[4, 9]]);})));it('execute() - "error" result should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {var call;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"type":"error","params": {"details": "this is an error"}}'));call = invoke.call(invoke.IOS.Class('GREYMatchers'), 'matcherForAccessibilityLabel:', 'test');_context10.prev = 4;_context10.next = 7;return client.execute(call);case 7:_context10.next = 12;break;case 9:_context10.prev = 9;_context10.t0 = _context10['catch'](4);expect(_context10.t0).toBeDefined();case 12:case 'end':return _context10.stop();}}}, _callee10, undefined, [[4, 9]]);})));it('execute() - unsupported result should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {var call;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:_context11.next = 2;return connect();case 2:client.ws.send.mockReturnValueOnce(Promise.resolve('{"unsupported":"unsupported"}'));call = invoke.call(invoke.IOS.Class('GREYMatchers'), 'matcherForAccessibilityLabel:', 'test');_context11.prev = 4;_context11.next = 7;return client.execute(call);case 7:_context11.next = 12;break;case 9:_context11.prev = 9;_context11.t0 = _context11['catch'](4);expect(_context11.t0).toBeDefined();case 12:case 'end':return _context11.stop();}}}, _callee11, undefined, [[4, 9]]);})));

});