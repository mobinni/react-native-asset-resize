'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var _ = require('lodash');
var config = require('../configurations.mock').validOneDeviceAndSession.session;

describe('AsyncWebSocket', function () {var connect = function () {var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(





































































































    function _callee11(client) {var result, promise;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:
              result = {};
              promise = client.open();
              client.ws.onopen(result);_context11.next = 5;return (
                promise);case 5:case 'end':return _context11.stop();}}}, _callee11, this);}));return function connect(_x) {return _ref11.apply(this, arguments);};}();var AsyncWebSocket = void 0;var WebSocket = void 0;var client = void 0;beforeEach(function () {jest.mock('npmlog');WebSocket = jest.mock('ws');WebSocket.OPEN = 1;WebSocket.CLOSED = 3;AsyncWebSocket = require('./AsyncWebSocket');client = new AsyncWebSocket(config.server);});it('new AsyncWebSocket - websocket onOpen should resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {var response, promise;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:response = { response: 'onopen' };promise = client.open();client.ws.onopen(response);_context.t0 = expect;_context.next = 6;return promise;case 6:_context.t1 = _context.sent;_context.t2 = response;(0, _context.t0)(_context.t1).toEqual(_context.t2);case 9:case 'end':return _context.stop();}}}, _callee, undefined);})));it('new AsyncWebSocket - websocket onError should reject', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {var error, promise;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:error = new Error();promise = client.open();client.ws.onerror(error);_context2.prev = 3;_context2.next = 6;return promise;case 6:_context2.next = 11;break;case 8:_context2.prev = 8;_context2.t0 = _context2['catch'](3);expect(_context2.t0).toEqual(error);case 11:case 'end':return _context2.stop();}}}, _callee2, undefined, [[3, 8]]);})));it('send message on a closed connection should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.prev = 0;_context3.next = 3;return client.send({ message: 'a message' });case 3:_context3.next = 8;break;case 5:_context3.prev = 5;_context3.t0 = _context3['catch'](0);expect(_context3.t0).toBeDefined();case 8:case 'end':return _context3.stop();}}}, _callee3, undefined, [[0, 5]]);})));it('send message should resolve upon returning message', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {var response, promise;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:response = { data: { response: 'onmessage' } };_context4.next = 3;return connect(client);case 3:promise = client.send({ message: 'a message' });client.ws.onmessage(response);_context4.t0 = expect;_context4.next = 8;return promise;case 8:_context4.t1 = _context4.sent;_context4.t2 = response.data;(0, _context4.t0)(_context4.t1).toEqual(_context4.t2);case 11:case 'end':return _context4.stop();}}}, _callee4, undefined);})));it('send message should reject upon error', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {var error, promise;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_context5.next = 2;return connect(client);case 2:error = new Error();promise = client.send({ message: 'a message' });client.ws.onerror(error);_context5.prev = 5;_context5.next = 8;return promise;case 8:_context5.next = 13;break;case 10:_context5.prev = 10;_context5.t0 = _context5['catch'](5);expect(_context5.t0).toEqual(error);case 13:case 'end':return _context5.stop();}}}, _callee5, undefined, [[5, 10]]);})));it('close a connected websocket should close and resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {var promise;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return connect(client);case 2:promise = client.close();client.ws.onclose({});_context6.t0 = expect;_context6.next = 7;return promise;case 7:_context6.t1 = _context6.sent;_context6.t2 = {};(0, _context6.t0)(_context6.t1).toEqual(_context6.t2);case 10:case 'end':return _context6.stop();}}}, _callee6, undefined);})));it('close a connected websocket should close and resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {var result, promise;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:result = {};_context7.next = 3;return connect(client);case 3:client.ws.readyState = WebSocket.OPEN;promise = client.close();client.ws.onclose(result);_context7.t0 = expect;_context7.next = 9;return promise;case 9:_context7.t1 = _context7.sent;_context7.t2 = result;(0, _context7.t0)(_context7.t1).toEqual(_context7.t2);case 12:case 'end':return _context7.stop();}}}, _callee7, undefined);})));it('close a disconnected websocket should resolve', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:_context8.next = 2;return connect(client);case 2:client.ws.readyState = WebSocket.CLOSED;_context8.next = 5;return client.close();case 5:expect(client.ws).toBeNull();case 6:case 'end':return _context8.stop();}}}, _callee8, undefined);})));it('client.isOpen() should return false when closed, open when opened', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:expect(client.isOpen()).toBe(false);_context9.next = 3;return connect(client);case 3:client.ws.readyState = WebSocket.OPEN;expect(client.isOpen()).toBe(true);case 5:case 'end':return _context9.stop();}}}, _callee9, undefined);})));it('closing a non-initialized websocket should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {var promise;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:promise = client.close();_context10.prev = 1;_context10.next = 4;return promise;case 4:_context10.next = 9;break;case 6:_context10.prev = 6;_context10.t0 = _context10['catch'](1);expect(_context10.t0).toBeDefined();case 9:case 'end':return _context10.stop();}}}, _callee10, undefined, [[1, 6]]);})));

});