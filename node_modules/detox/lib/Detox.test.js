'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var schemes = require('./configurations.mock');

describe('Detox', function () {
  var Detox = void 0;
  var detox = void 0;
  var minimist = void 0;

  beforeEach(_asyncToGenerator(regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
            jest.mock('minimist');
            minimist = require('minimist');
            jest.mock('./ios/expect');
            jest.mock('./client/Client');
            jest.mock('./devices/Simulator');
            jest.mock('detox-server');case 6:case 'end':return _context.stop();}}}, _callee, undefined);})));


  it('No config is passed to init, should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
            Detox = require('./Detox');
            try {
              detox = new Detox();
            } catch (ex) {
              expect(ex).toBeDefined();
            }case 2:case 'end':return _context2.stop();}}}, _callee2, undefined);})));


  it('Config with no devices, should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
            Detox = require('./Detox');_context3.prev = 1;

            detox = new Detox(schemes.invalidNoDevice);_context3.next = 5;return (
              detox.init());case 5:_context3.next = 10;break;case 7:_context3.prev = 7;_context3.t0 = _context3['catch'](1);

            expect(_context3.t0).toBeDefined();case 10:case 'end':return _context3.stop();}}}, _callee3, undefined, [[1, 7]]);})));



  it('Config with emulator, should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
            Detox = require('./Detox');_context4.prev = 1;

            detox = new Detox(schemes.invalidOneDeviceTypeEmulatorNoSession);_context4.next = 5;return (
              detox.init());case 5:_context4.next = 10;break;case 7:_context4.prev = 7;_context4.t0 = _context4['catch'](1);

            expect(_context4.t0).toBeDefined();case 10:case 'end':return _context4.stop();}}}, _callee4, undefined, [[1, 7]]);})));



  it('Passing --cleanup should shutdown the currently running device', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
            mockCommandLineArgs({ cleanup: true });
            Detox = require('./Detox');
            detox = new Detox(schemes.validOneDeviceNoSession);_context5.next = 5;return (
              detox.init());case 5:_context5.next = 7;return (
              detox.cleanup());case 7:
            expect(detox.device.shutdown).toHaveBeenCalledTimes(1);case 8:case 'end':return _context5.stop();}}}, _callee5, undefined);})));


  it('Not passing --cleanup should keep the currently running device up', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
            Detox = require('./Detox');
            detox = new Detox(schemes.validOneDeviceNoSession);_context6.next = 4;return (
              detox.init());case 4:_context6.next = 6;return (
              detox.cleanup());case 6:
            expect(detox.device.shutdown).toHaveBeenCalledTimes(0);case 7:case 'end':return _context6.stop();}}}, _callee6, undefined);})));


  it('One valid device, detox should init with generated session config and default to this device', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
            Detox = require('./Detox');
            detox = new Detox(schemes.validOneDeviceNoSession);_context7.next = 4;return (
              detox.init());case 4:

            expect(detox.detoxConfig.session.server).toBeDefined();case 5:case 'end':return _context7.stop();}}}, _callee7, undefined);})));


  it('One valid device, detox should use session config and default to this device', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
            Detox = require('./Detox');
            detox = new Detox(schemes.validOneDeviceAndSession);_context8.next = 4;return (
              detox.init());case 4:

            expect(detox.detoxConfig.session.server).toBe(schemes.validOneDeviceAndSession.session.server);
            expect(detox.detoxConfig.session.sessionId).toBe(schemes.validOneDeviceAndSession.session.sessionId);case 6:case 'end':return _context8.stop();}}}, _callee8, undefined);})));


  it('Two valid devices, detox should init with the device passed in \'--configuration\' cli option', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
            mockCommandLineArgs({ configuration: 'ios.sim.debug' });
            Detox = require('./Detox');

            detox = new Detox(schemes.validTwoDevicesNoSession);_context9.next = 5;return (
              detox.init());case 5:

            expect(detox.detoxConfig.configurations).toEqual(schemes.validTwoDevicesNoSession.configurations);case 6:case 'end':return _context9.stop();}}}, _callee9, undefined);})));


  it('Two valid devices, detox should init an ios.none device', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:
            mockCommandLineArgs({ configuration: 'ios.sim.none' });
            Detox = require('./Detox');

            detox = new Detox(schemes.validOneIosNoneDeviceNoSession);_context10.next = 5;return (
              detox.init());case 5:

            expect(detox.detoxConfig.configurations).toEqual(schemes.validOneIosNoneDeviceNoSession.configurations);case 6:case 'end':return _context10.stop();}}}, _callee10, undefined);})));


  it('Two valid devices, detox should throw if device passed in \'--configuration\' cli option doesn\'t exist', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:
            mockCommandLineArgs({ configuration: 'nonexistent' });
            Detox = require('./Detox');

            detox = new Detox(schemes.validTwoDevicesNoSession);_context11.prev = 3;_context11.next = 6;return (


              detox.init());case 6:_context11.next = 11;break;case 8:_context11.prev = 8;_context11.t0 = _context11['catch'](3);

            expect(_context11.t0).toBeDefined();case 11:case 'end':return _context11.stop();}}}, _callee11, undefined, [[3, 8]]);})));



  it('Two valid devices, detox should throw if device passed in \'--configuration\' cli option doesn\'t exist', _asyncToGenerator(regeneratorRuntime.mark(function _callee12() {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:
            mockCommandLineArgs({ configuration: 'nonexistent' });
            Detox = require('./Detox');

            detox = new Detox(schemes.validTwoDevicesNoSession);_context12.prev = 3;_context12.next = 6;return (


              detox.init());case 6:_context12.next = 11;break;case 8:_context12.prev = 8;_context12.t0 = _context12['catch'](3);

            expect(_context12.t0).toBeDefined();case 11:case 'end':return _context12.stop();}}}, _callee12, undefined, [[3, 8]]);})));



  it('One invalid device, detox should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:
            Detox = require('./Detox');

            detox = new Detox(schemes.invalidDeviceNoDeviceType);_context13.prev = 2;_context13.next = 5;return (


              detox.init());case 5:_context13.next = 10;break;case 7:_context13.prev = 7;_context13.t0 = _context13['catch'](2);

            expect(_context13.t0).toBeDefined();case 10:case 'end':return _context13.stop();}}}, _callee13, undefined, [[2, 7]]);})));



  it('cleanup on a non initialized detox should not throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {return regeneratorRuntime.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:
            Detox = require('./Detox');
            detox = new Detox(schemes.invalidDeviceNoDeviceType);
            //expect(detox.cleanup).not.toThrow();
            detox.cleanup();case 3:case 'end':return _context14.stop();}}}, _callee14, undefined);})));


  function mockCommandLineArgs(args) {
    minimist.mockReturnValue(args);
  }
});