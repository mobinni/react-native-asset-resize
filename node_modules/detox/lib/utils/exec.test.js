'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var _ = require('lodash');

describe('exec', function () {
  var exec = void 0;
  var cpp = void 0;

  beforeEach(function () {
    jest.mock('npmlog');
    jest.mock('child-process-promise');
    cpp = require('child-process-promise');
    exec = require('./exec');
  });

  it('exec command with no arguments successfully', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
            mockCppSuccessful(cpp);_context.next = 3;return (
              exec.execWithRetriesAndLogs('bin'));case 3:
            expect(cpp.exec).toHaveBeenCalledWith('bin');case 4:case 'end':return _context.stop();}}}, _callee, undefined);})));


  it('exec command with no arguments successfully', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {var successfulResult, resolvedPromise;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
            successfulResult = returnSuccessfulNoValue();
            resolvedPromise = Promise.resolve(successfulResult);
            cpp.exec.mockReturnValueOnce(resolvedPromise);_context2.next = 5;return (
              exec.execWithRetriesAndLogs('bin'));case 5:
            expect(cpp.exec).toHaveBeenCalledWith('bin');case 6:case 'end':return _context2.stop();}}}, _callee2, undefined);})));


  it('exec command with arguments successfully', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {var options;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
            mockCppSuccessful(cpp);

            options = { args: '--argument 123' };_context3.next = 4;return (
              exec.execWithRetriesAndLogs('bin', options));case 4:

            expect(cpp.exec).toHaveBeenCalledWith('bin --argument 123');case 5:case 'end':return _context3.stop();}}}, _callee3, undefined);})));


  it('exec command with arguments and prefix successfully', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {var options;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
            mockCppSuccessful(cpp);

            options = {
              args: '--argument 123',
              prefix: 'export MY_PREFIX' };_context4.next = 4;return (

              exec.execWithRetriesAndLogs('bin', options));case 4:

            expect(cpp.exec).toHaveBeenCalledWith('export MY_PREFIX && bin --argument 123');case 5:case 'end':return _context4.stop();}}}, _callee4, undefined);})));


  it('exec command with arguments and status logs successfully', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {var options, statusLogs;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
            mockCppSuccessful(cpp);

            options = { args: '--argument 123' };
            statusLogs = {
              trying: 'trying status log',
              successful: 'successful status log' };_context5.next = 5;return (

              exec.execWithRetriesAndLogs('bin', options, statusLogs));case 5:

            expect(cpp.exec).toHaveBeenCalledWith('bin --argument 123');case 6:case 'end':return _context5.stop();}}}, _callee5, undefined);})));


  it('exec command with undefined return should throw', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
            cpp.exec.mockReturnValueOnce(undefined);_context6.prev = 1;_context6.next = 4;return (

              exec.execWithRetriesAndLogs('bin'));case 4:
            fail('should throw');_context6.next = 10;break;case 7:_context6.prev = 7;_context6.t0 = _context6['catch'](1);

            expect(_context6.t0).toBeDefined();case 10:case 'end':return _context6.stop();}}}, _callee6, undefined, [[1, 7]]);})));



  it('exec command and fail', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {var errorResult, rejectedPromise;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
            errorResult = returnErrorWithValue('error result');
            rejectedPromise = Promise.reject(errorResult);
            cpp.exec.mockReturnValueOnce(rejectedPromise);_context7.prev = 3;_context7.next = 6;return (


              exec.execWithRetriesAndLogs('bin', null, '', 1, 1));case 6:
            fail('expected execWithRetriesAndLogs() to throw');_context7.next = 13;break;case 9:_context7.prev = 9;_context7.t0 = _context7['catch'](3);

            expect(cpp.exec).toHaveBeenCalledWith('bin');
            expect(_context7.t0).toBeDefined();case 13:case 'end':return _context7.stop();}}}, _callee7, undefined, [[3, 9]]);})));



  it('exec command with multiple failures', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {var errorResult, rejectedPromise;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
            errorResult = returnErrorWithValue('error result');
            rejectedPromise = Promise.reject(errorResult);
            cpp.exec.mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise);_context8.prev = 3;_context8.next = 6;return (

              exec.execWithRetriesAndLogs('bin', null, '', 6, 1));case 6:
            fail('expected execWithRetriesAndLogs() to throw');_context8.next = 14;break;case 9:_context8.prev = 9;_context8.t0 = _context8['catch'](3);

            expect(cpp.exec).toHaveBeenCalledWith('bin');
            expect(cpp.exec).toHaveBeenCalledTimes(6);
            expect(_context8.t0).toBeDefined();case 14:case 'end':return _context8.stop();}}}, _callee8, undefined, [[3, 9]]);})));



  it('exec command with multiple failures and then a success', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {var errorResult, rejectedPromise, successfulResult, resolvedPromise;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
            errorResult = returnErrorWithValue('error result');
            rejectedPromise = Promise.reject(errorResult);
            successfulResult = returnSuccessfulWithValue('successful result');
            resolvedPromise = Promise.resolve(successfulResult);

            cpp.exec.mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(rejectedPromise).
            mockReturnValueOnce(resolvedPromise);_context9.next = 7;return (

              exec.execWithRetriesAndLogs('bin', null, '', 6, 1));case 7:
            expect(cpp.exec).toHaveBeenCalledWith('bin');
            expect(cpp.exec).toHaveBeenCalledTimes(6);case 9:case 'end':return _context9.stop();}}}, _callee9, undefined);})));

});

function returnSuccessfulWithValue(value) {
  var result = {
    stdout: JSON.stringify(value),
    stderr: "err",
    childProcess: {
      exitCode: 0 } };


  return result;
}

function returnErrorWithValue(value) {
  var result = {
    stdout: "out",
    stderr: value,
    childProcess: {
      exitCode: 1 } };


  return result;
}

function returnSuccessfulNoValue() {
  var result = {
    childProcess: {
      exitCode: 0 } };


  return result;
}

function mockCppSuccessful(cpp) {
  var successfulResult = returnSuccessfulWithValue('successful result');
  var resolvedPromise = Promise.resolve(successfulResult);
  cpp.exec.mockReturnValueOnce(resolvedPromise);

  return successfulResult;
}