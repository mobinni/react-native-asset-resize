'use strict';var init = function () {var _ref = _asyncToGenerator(regeneratorRuntime.mark(



  function _callee(config) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
            detox = new Detox(config);_context.next = 3;return (
              detox.init());case 3:case 'end':return _context.stop();}}}, _callee, this);}));return function init(_x) {return _ref.apply(this, arguments);};}();var cleanup = function () {var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(


  function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:if (!
            detox) {_context2.next = 3;break;}_context2.next = 3;return (
              detox.cleanup());case 3:case 'end':return _context2.stop();}}}, _callee2, this);}));return function cleanup() {return _ref2.apply(this, arguments);};}();



//// if there's an error thrown, close the websocket,
//// if not, mocha will continue running until reaches timeout.
//process.on('uncaughtException', (err) => {
//  //client.close();
//
//  throw err;
//});
//
//process.on('unhandledRejection', (reason, p) => {
//  //client.close();
//
//  throw reason;
//});
function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var Detox = require('./Detox');var detox = void 0;
module.exports = {
  init: init,
  cleanup: cleanup };